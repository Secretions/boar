#!/usr/bin/python
# -*- coding: utf-8 -*-

# Copyright 2010 Mats Ekberg
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import with_statement
import sys
import os
from time import time, ctime
import cProfile
from optparse import OptionParser
from blobrepo import repository
from blobrepo.sessions import bloblist_fingerprint
from boar_exceptions import *
import client

if sys.version_info >= (2, 6):
    import json
else:
    import simplejson as json

from front import Front
import workdir
from common import *
import settings

def print_help():
    print """Usage: 
import [-w] [-u] <dir> <session_name>
co <session_name> [destination]
mkrepo <dir to create>
list [session_name [revision_id]]
find <filename>
"""

def list_sessions(front):
    sessions_count = {}
    for sid in front.get_session_ids():
        session_info = front.get_session_info(sid)
        name = session_info.get("name", "<no name>")
        sessions_count[name] = sessions_count.get(name, 0) + 1
    for name in sessions_count:
        print name, "(" + str(sessions_count[name]) + " revs)"

def list_revisions(front, session_name):
    for sid in front.get_session_ids():
        session_info = front.get_session_info(sid)
        bloblist = front.get_session_bloblist(sid)
        name = session_info.get("name", "<no name>")
        if name != session_name:
            continue
        print "Revision id", str(sid), "(" + session_info['date'] + "),", \
            len(bloblist), "files"

def list_files(front, session_name, revision):
    session_info = front.get_session_info(revision)
    name = session_info.get("name", "<no name>")
    if name != session_name:
        print "There is no such session/revision"
        return
    for info in front.get_session_bloblist(revision):
        print info['filename'], str(info['size']/1024+1) + "k"

def verify_repo(repo, verify_blobs = True):
    front = Front(repo)
    print "Verifying repo", repo
    print "Collecting a list of all sessions..."
    session_ids = front.get_session_ids()
    print "Verifying %s sessions" % (len(session_ids))
    ok_blobs = set()
    for i in range(0, len(session_ids)):
        id = session_ids[i]
        bloblist = front.get_session_bloblist(id)
        calc_fingerprint = bloblist_fingerprint(bloblist)
        assert calc_fingerprint == front.get_session_property(id, "fingerprint"), \
            "Fingerprint didn't match for session "+str(id)
        for bi in bloblist:
            assert bi['md5sum'] in ok_blobs or \
                front.has_blob(bi['md5sum']), "Session %s is missing blob %s" \
                % (session_ids[i], bi['md5sum'])
            ok_blobs.add(bi['md5sum'])
        print "Snapshot %s (%s): All %s blobs ok" % (id, calc_fingerprint, len(bloblist))
    if not verify_blobs:
        print "Skipping blob verification"
        return True
    print "Collecting a list of all blobs..."
    count = front.init_verify_blobs()
    print "Verifying %s blobs..." % (count)
    done = 0
    while done < count:
        done += len(front.verify_some_blobs())
        print done, "of "+str(count)+" blobs verified, "+ \
            str(round(1.0*done/count * 100,1)) + "% done."
    return True

def cmd_locate(front, args):
    assert len(args) == 1, "Session name must be given"
    sessionName = args[0]
    repo_path = os.getenv("REPO_PATH")
    root = os.getcwd().decode(sys.getfilesystemencoding())
    tree = get_tree(root)
    tree.sort()
    wd = workdir.Workdir(front.get_repo_path(), sessionName, "", None, root)
    missing = []
    found = 0
    for f in tree:
        csum = md5sum_file(f)
        session_filenames = list(wd.get_filesnames(csum))
        session_dirs = [os.path.dirname(fn) for fn in session_filenames]
        if not session_filenames:
            print "Missing:", f
            missing.append(f)
            continue
        if session_filenames:
            print "OK:", f
            found += 1
            for p in session_filenames:
                print "   " + p
    print "%s files exists in the given session, %s do not." % (found, missing)
    for f in missing:
        print "Missing:",f

def cmd_status(args):
    verbose = ("-v" in args)
    wd = workdir.init_workdir(os.getcwd())
    assert wd, "No workdir found here"
    unchanged_files, new_files, modified_files, deleted_files, ignored_files \
        = wd.get_changes()
    filestats = {}
    def in_session(f):
        f_wd = strip_path_offset(wd.offset, f)
        return "S" if wd.exists_in_session(wd.cached_md5sum(f_wd)) else " "
    def in_workdir(f):
        csum = wd.get_blobinfo(f)['md5sum']
        return "W" if wd.exists_in_workdir(csum) else " "

    for f in new_files:
        filestats[f] = "A" + in_session(f)
    for f in modified_files:
        filestats[f] = "M" + in_workdir(f)
    for f in deleted_files:
        filestats[f] = "D" + in_workdir(f)
    if verbose:
        for f in unchanged_files:
            filestats[f] = " "
        for f in ignored_files:
            filestats[f] = "i"
    filenames = filestats.keys()
    filenames.sort()
    for f in filenames:
        print filestats[f], f

def cmd_info(args):
    wd = workdir.init_workdir(os.getcwd())
    if wd:
        print "Using a work directory:"
        print "   Workdir root:", wd.root
        print "   Repository:", wd.repoUrl
        print "   Session:", wd.sessionName, "/", wd.offset
        print "   Revision:", wd.revision
        
    #env_front = init_repo_from_env()

def cmd_mkrepo(args):
    repository.create_repository(args[0])


def cmd_list(front, args):
    if len(args) == 0:
        list_sessions(front)
    elif len(args) == 1:
        list_revisions(front, args[0])
    elif len(args) == 2:
        list_files(front, args[0], args[1])
    else:
        print "Duuuh?"

def cmd_verify(front, args):
    verify_repo(front.repo)

def cmd_import(front, args):
    parser = OptionParser(usage="usage: %prog [options] <folder to import> <snapshot name>[/imported name]")
    parser.add_option("-v", "--verbose", dest = "verbose", action="store_true",
                      help="Show more details about what is happening.")
    parser.add_option("-n", "--dry-run", dest = "dry_run", action="store_true",
                      help="Don't actually do anything. Just show what will happen.")
    parser.add_option("-w", "--create-workdir", dest = "create_workdir", action="store_true",
                      help="Turn the imported directory into a workdir.")
    base_session = None
    (options, args) = parser.parse_args(args)
    assert len(args) <= 2
    path_to_ci = os.path.abspath(args[0]).decode()
    session_name = os.path.basename(args[0]) #TODO: what happens when giving only one arg?
    session_offset = ""
    if len(args) > 1:
        if "/" in args[1]:
            # TODO: this won't work so well with windows paths
            session_name, session_offset = args[1].split("/", 1)
        else:
            session_name = args[1]
    if options.verbose:
        print "Session name:", session_name, "Session offset:", session_offset
    if not os.path.exists(path_to_ci):
        raise UserError("Path to check in does not exist: " + path_to_ci)
    if not front.find_last_revision(session_name):
        raise UserError("No session with the name '%s' exists." % (session_name))
    wd = workdir.Workdir(front.get_repo_path(), session_name, session_offset, None, path_to_ci)
    if options.verbose:
        wd.setLogOutput(sys.stdout)
    session_id = wd.checkin(write_meta = options.create_workdir, 
                            add_only = True, dry_run = options.dry_run)
    print "Checked in session id", session_id

def cmd_update(wd, args):
    wd.update()

def cmd_ci(wd, args):
    session_id = wd.checkin()
    print "Checked in session id", session_id

def cmd_mksession(front, args):
    session_name, = args
    if front.find_last_revision(session_name) != None:
        raise UserError("There already exists a session named '%s'" % (session_name))
    front.mksession(session_name)
    print "New session '%s' was created successfully" % (session_name)

def cmd_co(front, args): 
    session_ids = front.get_session_ids()
    session_ids.reverse()
    session_name, throwaway, offset = args[0].partition("/")

    if len(args) <= 1:
        workdir_path = os.path.abspath(session_name).decode()
    else:
        workdir_path = os.path.abspath(args[1]).decode()
    print "Exporting to workdir", workdir_path

    for sid in session_ids:
        session_info = front.get_session_info(sid)
        name = session_info.get("name", "<no name>")
        if name == session_name:
            break
    if name != session_name:
        print "No session named '%s' found" % (session_name)
        return
    assert not os.path.exists(workdir_path)
    os.mkdir(workdir_path)
    wd = workdir.Workdir(front.get_repo_path(), session_name, offset, sid, workdir_path)
    wd.checkout()

def cmd_find(front, args):
    filename, = args
    cs = md5sum_file(filename)
    all_ids = front.get_session_ids()
    all_ids.sort()
    all_ids.reverse()
    seen = set()
    for i in all_ids:
        info = front.get_session_info(i)
        if info['name'] in seen:
            continue
        seen.add(info['name'])
        for bi in front.get_session_bloblist(i):
            if bi['md5sum'] == cs:
                print info['name'] +":"+bi['filename']

def cmd_clone(args):
    repopath1, repopath2 = args
    if repopath1.startswith("boar://") or repopath2.startswith("boar://"):
        raise UserError("Cloning requires local repositories")
    repopath1 = os.path.abspath(repopath1)
    repopath2 = os.path.abspath(repopath2)
    repo1 = repository.Repo(repopath1) # todo: handle errors nicely
    if not os.path.exists(repopath2):
        repository.create_repository(repopath2)
    repo2 = repository.Repo(repopath2)
    if repo1.isIdentical(repo2):
        print "Repositories are already identical"
        return
    print "Quick verifying source repo"
    verify_repo(repo1, verify_blobs = False)
    print "Quick verifying destination repo"
    verify_repo(repo2, verify_blobs = False)
    repo2.pullFrom(repo1)
    print "Performing full verify on cloned repo"
    verify_repo(repo2, verify_blobs = True)

def cmd_diffrepo(args):
    global return_code
    repopath1, repopath2 = args
    if repopath1.startswith("boar://") or repopath2.startswith("boar://"):
        raise UserError("Cloning requires local repositories")
    repopath1 = os.path.abspath(repopath1)
    repopath2 = os.path.abspath(repopath2)
    repo1 = repository.Repo(repopath1) # todo: handle errors nicely
    repo2 = repository.Repo(repopath2)
    if repo1.isIdentical(repo2):
        assert repo2.isIdentical(repo1)
        print "Repositories are identical"
        return_code = 0
    else:
        print "Repositories differ"
        return_code = 1

def cmd_export_md5(wd, args):
    wd.export_md5()

def init_repo_from_env(repo_from_cmdline):
    repopath = os.getenv("REPO_PATH")
    if repo_from_cmdline:
        repopath = repo_from_cmdline
    front = None
    msg = None
    if not repopath:
        raise UserError("You need to specify a repository to operate on."+\
                            "Use the --repo option or set $REPO_PATH.")
    elif repopath.startswith("boar://"):
        front = client.connect(repopath)
    else:
        repopath = os.path.abspath(repopath)
        if not os.path.exists(repopath):
            raise UserError("Provided repository path does not exist: "+repopath)
        front = Front(repository.Repo(repopath))
    assert front
    return front

def main():    
    if len(sys.argv) <= 1:
        print_help()
        return

    args = sys.argv[1:]
    cmdline_repo = None
    for i in range(0, len(args)):
        # This is ridiculous, but I just can't get OptParse to just
        # look for --repo without exploding on other "unknown options".
        # TODO: make less silly
        if args[i] == "--repo":
            args.pop(i)
            try:
                cmdline_repo = args.pop(i) 
                break
            except:
                raise UserError("You must specify a valid repository after --repo")
        if args[i].startswith("--repo="):
            _, cmdline_repo = args.pop(i).split("=")
            break

    if args[0] == "mkrepo":
        cmd_mkrepo(args[1:])
        return
    if args[0] == "import":
        front = init_repo_from_env(cmdline_repo)
        cmd_import(front, args[1:])
    elif args[0] == "list":
        front = init_repo_from_env(cmdline_repo)
        cmd_list(front, args[1:])
    elif args[0] == "verify":
        front = init_repo_from_env(cmdline_repo)
        cmd_verify(front, args[1:])
    elif args[0] == "co":
        front = init_repo_from_env(cmdline_repo)
        cmd_co(front, args[1:])
    elif args[0] == "status":
        cmd_status(args[1:])
    elif args[0] == "info":
        cmd_info(args[1:])
    elif args[0] == "ci":
        wd = workdir.init_workdir(os.getcwd())
        cmd_ci(wd, args[1:])
    elif args[0] == "update":
        wd = workdir.init_workdir(os.getcwd())
        cmd_update(wd, args[1:])
    elif args[0] == "find":
        front = init_repo_from_env(cmdline_repo)
        cmd_find(front, args[1:])
    elif args[0] == "locate":
        front = init_repo_from_env(cmdline_repo)
        cmd_locate(front, args[1:])
    elif args[0] == "mksession":
        front = init_repo_from_env(cmdline_repo)
        cmd_mksession(front, args[1:])
    elif args[0] == "exportmd5":
        wd = workdir.init_workdir(os.getcwd())
        cmd_export_md5(wd, args[1:])
    elif args[0] == "clone":
        cmd_clone(args[1:])
    elif args[0] == "diffrepo":
        cmd_diffrepo(args[1:])
    else:
        print_help()
        return


return_code = 0
if __name__ == "__main__":
    t1 = time()
    #cProfile.run('main()', "prof.txt")
    #import pstats
    #p = pstats.Stats('prof.txt')
    #p.sort_stats('cum').print_stats(10)
    try:
        main()
    except UserError as e:
        print "ERROR:", e.value
        return_code = 1
    t2 = time()
    print "Finished in", round(t2-t1, 2), "seconds"
    sys.exit(return_code)
