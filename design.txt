* Hardware and software errors - the integrity and completeness of the
  repository can be verified automatically. The repository operations
  are atomic. All files are write-once, added data never affects
  existing meta files.

* User error - The system never physically deletes any information
  that has been added. Additionally, sessions are normally add-only,
  to make it harder to lose a file. Files within sessions can only be
  moved, not removed.

* Software obsolescence - The system is easy enough to understand to
  at least allow for extraction of data with a relatively simple
  program, without the need of compression algorithms or complex data
  formats.

SiLL

Inga filer tas bort, någonsin.


Strukturen liknar SVN.

Backenden baserad på zip-ar? Ett arkiv per fil, med versioner namngivna baserat på datum?

Info-fil i varje hanterad katalog med md5-summor och annan info.

Checkpoints, en lista av datum med kommentarer helt enkelt, istället för atomära commits.

Varje arkiv i repositoryt kan ha flera sessioner. Så när man checkat
in/ut ett arkiv så har katalogen en infofil som talar om vilket arkiv
det handlar om (likt svn), och låter en checka in en ny version av
arkivet.

Detta kan implementeras genom att i backenden bara checka in
sessioner, utan individuell koppling till andra sessioner, och göra
kopplingen i metadata för sessionen som kommer från klientsidan.

Hur göra atomära commits med flera filer?  

* Strunta i atomiciteten och commita filerna en och en, möjligen med
en garbning ibland. Nackdel: olänkade filer blir ett normalt tillstånd
istället för en felindikator.

* Använd flytt av katalog som commit. Nackdel: måste köra en
"recovery" före varje start för att färdigställa ev. commit.


